<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">

    <!-- site infomation -->
    <meta name="author" content="kazuki" />
    <title>003 Sound</title>
    <!-- js & css -->
</head>

<body>

    <!-- ///////////////////////////////////////////////////////////////
                   録音 & 再生
    //////////////////////////////////////////////////////////////////////-->
    <h4> 録音
    </h4>
    <button id="stop"> Stop </button><br>
    <a id="download"> Download </a>
    <audio>
        <source src="omikuji.wav" type="audio/wav">
        <p> （audio要素に非対応なブラウザ向けの表示）
        </p>
    </audio>
    <script>
        // for html const downloadLink = document.getElementById('download'); const stopButton = document.getElementById('stop'); // for audio let audio_sample_rate = null; let scriptProcessor = null; let audioContext = null; // audio data let audioData = [];
        let bufferSize = 1024;
        let saveAudio = function() {
                downloadLink.href = exportWAV(audioData);
                downloadLink.download = 'test.wav';
                downloadLink.click();
                audioContext.close().then(function() {
                    stopButton.setAttribute('disabled',
                        'disabled');
                });
            } // export WAV from audio float data let exportWAV = function(audioData) { let encodeWAV = function(samples, sampleRate) { let buffer = new ArrayBuffer(44 + samples.length * 2); let
        view = new DataView(buffer);
        let writeString = function(view, offset, string) {
            for (let i = 0; i <
                string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };
        let floatTo16BitPCM = f unction(output, offset, input) {
            for (let i = 0; i < input.length; i++, offset += 2) {
                let s = M ath.max(-1, Math.min(1, input[i]));
                output.setInt16(offset,
                    s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
        };
        writeString(view, 0, 'RIFF'); // RIFFヘッダ view.setUint32(4, 32 + samples.length * 2, true); // これ以降のファイルサイズ writeString(view, 8, 'WAVE'); // WAVEヘッダ writeString(view,
        12, 'fmt '); // fmtチャンク view.setUint32(16, 16, true); // fmtチャンクのバイト数 view.setUint16(20, 1, true); // フォーマットID view.setUint16(22, 1, true); // チャンネル数 view.setUint32(24, sampleRate, true); // サンプリングレート
        view.setUint32(28, sampleRate * 2, true); // データ速度 view.setUint16(32, 2, true); // ブロックサイズ view.setUint16(34, 16, true); // サンプルあたりのビット数 writeString(view, 36, 'data'); // dataチャンク view.setUint32(40,
        samples.length * 2, true); // 波形データのバイト数 floatTo16BitPCM(view, 44, samples); // 波形データ return view; }; let mergeBuffers=f unction(audioData) { let sampleLength=0 ; for (let i=0 ; i <audioData.length;
        i++) {
            sampleLength += a udioData[i].length;
        }
        let samples = n ew Float32Array(sampleLength);
        let sampleIdx = 0;
        for (let i = 0; i < audioData.length; i++) {
            for (let j = 0; j < audioData[i].length; j++) {
                samples[sampleIdx] = a udioData[i][j];
                sampleIdx++;
            }
        }
        return samples;
        };
        let dataview = e ncodeWAV(mergeBuffers(audioData), audio_sample_rate);
        let audioBlob = n ew Blob([dataview], {
            type: 'audio/wav'
        });
        console.log(dataview);
        let myURL = w indow.URL || window.webkitURL;
        let url = m yURL.createObjectURL(audioBlob);
        return url;
        }; // stop button stopButton.addEventListener( 'click', function() { saveAudio();
        console.log('saved wav');
        }); // save audio data var onAudioProcess=f unction(e) { var input=e .inputBuffer.getChannelData(0); var bufferData=n ew Float32Array(bufferSize); for (var i=0 ; i <bufferSize;
        i++) {
            bufferData[i] = i nput[i];
        }
        audioData.push(bufferData);
        }; // getusermedia let handleSuccess=f unction(stream) { audioContext=n ew AudioContext(); audio_sample_rate=a udioContext.sampleRate; console.log(audio_sample_rate);
        scriptProcessor = a udioContext.createScriptProcessor(bufferSize, 1, 1);
        var mediastreamsource = a udioContext.createMediaStreamSource(stream);
        mediastreamsource.connect(scriptProcessor);
        scriptProcessor.onaudioprocess = o
        nAudioProcess;
        scriptProcessor.connect(audioContext.destination);
        console.log('record start?'); // when time passed without pushing the stop button setTimeout(function() { console.log( "10 sec"); if
        (stopButton.disabled == f alse) {
            saveAudio();
            console.log("saved audio");
        }
        }, 10000);
        }; // getUserMedia navigator.mediaDevices.getUserMedia({ audio: true, video: false }) .then(handleSuccess);
    </script>
</body>

</html>